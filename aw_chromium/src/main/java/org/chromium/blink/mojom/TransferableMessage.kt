// TransferableMessage.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/messaging/transferable_message.mojom
//
package org.chromium.blink.mojom

import org.chromium.mojo.bindings.BindingsHelper
import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.Struct
import org.chromium.skia.mojom.BitmapN32
import org.chromium.url.internal.mojom.Origin.Companion.decode
import java.nio.ByteBuffer

class TransferableMessage private constructor(version: Int) : Struct(STRUCT_SIZE, version) {
    @JvmField
    var message: CloneableMessage? = null
    @JvmField
    var ports: Array<MessagePortDescriptor?>? = null

    @JvmField
    var streamChannels: Array<MessagePortDescriptor?>? = null

    @JvmField
    var arrayBufferContentsArray: Array<SerializedArrayBufferContents?>? = null

    @JvmField
    var imageBitmapContentsArray: Array<BitmapN32?>? = null
    var userActivation: UserActivationSnapshot? = null
    var delegatePaymentRequest = false

    constructor() : this(0)

    override fun encode(encoder: Encoder) {
        val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        encoder0.encode(message, 8, false)
        if (ports == null) {
            encoder0.encodeNullPointer(16, false)
        } else {
            val encoder1 = encoder0.encodePointerArray(
                ports!!.size,
                16,
                BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
            )
            for (i0 in ports!!.indices) {
                encoder1.encode(
                    ports!![i0],
                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i0,
                    false
                )
            }
        }
        if (streamChannels == null) {
            encoder0.encodeNullPointer(24, false)
        } else {
            val encoder1 = encoder0.encodePointerArray(
                streamChannels!!.size,
                24,
                BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
            )
            for (i0 in streamChannels!!.indices) {
                encoder1.encode(
                    streamChannels!![i0],
                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i0,
                    false
                )
            }
        }
        if (arrayBufferContentsArray == null) {
            encoder0.encodeNullPointer(32, false)
        } else {
            val encoder1 = encoder0.encodePointerArray(
                arrayBufferContentsArray!!.size,
                32,
                BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
            )
            for (i0 in arrayBufferContentsArray!!.indices) {
                encoder1.encode(
                    arrayBufferContentsArray!![i0],
                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i0,
                    false
                )
            }
        }
        if (imageBitmapContentsArray == null) {
            encoder0.encodeNullPointer(40, false)
        } else {
            val encoder1 = encoder0.encodePointerArray(
                imageBitmapContentsArray!!.size,
                40,
                BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
            )
            for (i0 in imageBitmapContentsArray!!.indices) {
                encoder1.encode(
                    imageBitmapContentsArray!![i0],
                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i0,
                    false
                )
            }
        }
        encoder0.encode(userActivation, 48, true)
        encoder0.encode(delegatePaymentRequest, 56, 0)
    }

    companion object {
        private const val STRUCT_SIZE = 64
        private val VERSION_ARRAY = arrayOf(DataHeader(64, 0))
        private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
        @JvmStatic
        fun deserialize(message: Message?): TransferableMessage? {
            return decode(Decoder(message))
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        fun deserialize(data: ByteBuffer?): TransferableMessage? {
            return deserialize(
                Message(
                    data, ArrayList()
                )
            )
        }

        fun decode(decoder0: Decoder?): TransferableMessage? {
            if (decoder0 == null) {
                return null
            }
            decoder0.increaseStackDepth()
            val result: TransferableMessage
            try {
                val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                val elementsOrVersion = mainDataHeader.elementsOrVersion
                result = TransferableMessage(elementsOrVersion)
                run {
                    val decoder1 = decoder0.readPointer(8, false)
                    result.message = CloneableMessage.Companion.decode(decoder1)
                }
                run {
                    val decoder1 = decoder0.readPointer(16, false)
                    run {
                        val si1 =
                            decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                        result.ports = arrayOfNulls(si1.elementsOrVersion)
                        for (i1 in 0 until si1.elementsOrVersion) {
                            val decoder2 = decoder1.readPointer(
                                DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i1,
                                false
                            )
                            result.ports!![i1] = MessagePortDescriptor.Companion.decode(decoder2)
                        }
                    }
                }
                run {
                    val decoder1 = decoder0.readPointer(24, false)
                    run {
                        val si1 =
                            decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                        result.streamChannels = arrayOfNulls(si1.elementsOrVersion)
                        for (i1 in 0 until si1.elementsOrVersion) {
                            val decoder2 = decoder1.readPointer(
                                DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i1,
                                false
                            )
                            result.streamChannels!![i1] =
                                MessagePortDescriptor.Companion.decode(decoder2)
                        }
                    }
                }
                run {
                    val decoder1 = decoder0.readPointer(32, false)
                    run {
                        val si1 =
                            decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                        result.arrayBufferContentsArray = arrayOfNulls(si1.elementsOrVersion)
                        for (i1 in 0 until si1.elementsOrVersion) {
                            val decoder2 = decoder1.readPointer(
                                DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i1,
                                false
                            )
                            result.arrayBufferContentsArray!![i1] =
                                SerializedArrayBufferContents.Companion.decode(decoder2)
                        }
                    }
                }
                run {
                    val decoder1 = decoder0.readPointer(40, false)
                    run {
                        val si1 =
                            decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                        result.imageBitmapContentsArray = arrayOfNulls(si1.elementsOrVersion)
                        for (i1 in 0 until si1.elementsOrVersion) {
                            val decoder2 = decoder1.readPointer(
                                DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i1,
                                false
                            )
                            result.imageBitmapContentsArray!![i1] = BitmapN32.decode(decoder2)
                        }
                    }
                }
                run {
                    val decoder1 = decoder0.readPointer(48, true)
                    result.userActivation = UserActivationSnapshot.Companion.decode(decoder1)
                }
                run { result.delegatePaymentRequest = decoder0.readBoolean(56, 0) }
            } finally {
                decoder0.decreaseStackDepth()
            }
            return result
        }
    }
}