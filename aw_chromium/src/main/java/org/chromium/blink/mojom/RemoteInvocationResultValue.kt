// RemoteInvocationResultValue.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/remote_objects/remote_objects.mojom
//
package org.chromium.blink.mojom

import org.chromium.mojo.bindings.BindingsHelper
import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.Union
import org.chromium.mojo_base.mojom.String16

class RemoteInvocationResultValue : Union() {
    object Tag {
        const val NumberValue = 0
        const val BooleanValue = 1
        const val StringValue = 2
        const val SingletonValue = 3
        const val ObjectId = 4
    }

    private var mNumberValue = 0.0
    private var mBooleanValue = false
    private var mStringValue: String16? = null
    private var mSingletonValue = 0
    private var mObjectId = 0
    var numberValue: Double
        get() {
            assert(mTag == Tag.NumberValue)
            return mNumberValue
        }
        set(numberValue) {
            mTag = Tag.NumberValue
            mNumberValue = numberValue
        }
    var booleanValue: Boolean
        get() {
            assert(mTag == Tag.BooleanValue)
            return mBooleanValue
        }
        set(booleanValue) {
            mTag = Tag.BooleanValue
            mBooleanValue = booleanValue
        }
    var stringValue: String16?
        get() {
            assert(mTag == Tag.StringValue)
            return mStringValue
        }
        set(stringValue) {
            mTag = Tag.StringValue
            mStringValue = stringValue
        }
    var singletonValue: Int
        get() {
            assert(mTag == Tag.SingletonValue)
            return mSingletonValue
        }
        set(singletonValue) {
            mTag = Tag.SingletonValue
            mSingletonValue = singletonValue
        }
    var objectId: Int
        get() {
            assert(mTag == Tag.ObjectId)
            return mObjectId
        }
        set(objectId) {
            mTag = Tag.ObjectId
            mObjectId = objectId
        }

    override fun encode(encoder0: Encoder, offset: Int) {
        encoder0.encode(BindingsHelper.UNION_SIZE, offset)
        encoder0.encode(mTag, offset + 4)
        when (mTag) {
            Tag.NumberValue -> {
                encoder0.encode(mNumberValue, offset + 8)
            }

            Tag.BooleanValue -> {
                encoder0.encode(mBooleanValue, offset + 8, 0)
            }

            Tag.StringValue -> {
                encoder0.encode(mStringValue, offset + 8, false)
            }

            Tag.SingletonValue -> {
                encoder0.encode(mSingletonValue, offset + 8)
            }

            Tag.ObjectId -> {
                encoder0.encode(mObjectId, offset + 8)
            }

            else -> {}
        }
    }

    companion object {
        fun deserialize(message: Message?): RemoteInvocationResultValue? {
            return decode(Decoder(message).decoderForSerializedUnion(), 0)
        }

        fun decode(decoder0: Decoder, offset: Int): RemoteInvocationResultValue? {
            val dataHeader = decoder0.readDataHeaderForUnion(offset)
            if (dataHeader.size == 0) {
                return null
            }
            val result = RemoteInvocationResultValue()
            when (dataHeader.elementsOrVersion) {
                Tag.NumberValue -> {
                    result.mNumberValue = decoder0.readDouble(offset + DataHeader.HEADER_SIZE)
                    result.mTag = Tag.NumberValue
                }

                Tag.BooleanValue -> {
                    result.mBooleanValue = decoder0.readBoolean(offset + DataHeader.HEADER_SIZE, 0)
                    result.mTag = Tag.BooleanValue
                }

                Tag.StringValue -> {
                    val decoder1 = decoder0.readPointer(offset + DataHeader.HEADER_SIZE, false)
                    result.mStringValue = String16.decode(decoder1)
                    result.mTag = Tag.StringValue
                }

                Tag.SingletonValue -> {
                    result.mSingletonValue = decoder0.readInt(offset + DataHeader.HEADER_SIZE)
                    SingletonJavaScriptValue.validate(result.mSingletonValue)
                    result.mSingletonValue =
                        SingletonJavaScriptValue.toKnownValue(result.mSingletonValue)
                    result.mTag = Tag.SingletonValue
                }

                Tag.ObjectId -> {
                    result.mObjectId = decoder0.readInt(offset + DataHeader.HEADER_SIZE)
                    result.mTag = Tag.ObjectId
                }

                else -> {}
            }
            return result
        }
    }
}