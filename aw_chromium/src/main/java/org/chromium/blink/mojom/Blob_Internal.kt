// Blob_Internal.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/blob/blob.mojom
//
package org.chromium.blink.mojom

import org.chromium.blink.mojom.Blob.CaptureSnapshotResponse
import org.chromium.blink.mojom.Blob.GetInternalUuidResponse
import org.chromium.blink.mojom.Blob.ReadSideDataResponse
import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.DeserializationException
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Interface
import org.chromium.mojo.bindings.Interface.AbstractProxy
import org.chromium.mojo.bindings.Interface.Manager
import org.chromium.mojo.bindings.InterfaceControlMessagesHelper
import org.chromium.mojo.bindings.InterfaceRequest
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.MessageHeader
import org.chromium.mojo.bindings.MessageReceiver
import org.chromium.mojo.bindings.MessageReceiverWithResponder
import org.chromium.mojo.bindings.SideEffectFreeCloseable
import org.chromium.mojo.bindings.Struct
import org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants
import org.chromium.mojo.system.Core
import org.chromium.mojo.system.DataPipe.ProducerHandle
import org.chromium.mojo.system.InvalidHandle
import org.chromium.mojo_base.mojom.BigBuffer
import org.chromium.mojo_base.mojom.Time
import org.chromium.network.mojom.DataPipeGetter
import org.chromium.network.mojom.HttpRequestHeaders
import org.chromium.network.mojom.UrlLoader
import org.chromium.network.mojom.UrlLoaderClient
import java.nio.ByteBuffer

internal object Blob_Internal {
    val MANAGER: Manager<Blob?, Blob.Proxy?> = object : Manager<Blob?, Blob.Proxy?>() {
        override fun getName(): String {
            return "blink.mojom.Blob"
        }

        override fun getVersion(): Int {
            return 0
        }

        public override fun buildProxy(
            core: Core,
            messageReceiver: MessageReceiverWithResponder
        ): Proxy {
            return Proxy(core, messageReceiver)
        }

        override fun buildStub(core: Core?, impl: Blob?): Interface.Stub<Blob?> {
            return Stub(core, impl)
        }

        public override fun buildArray(size: Int): Array<Blob?> {
            return arrayOfNulls(size)
        }
    }
    private const val CLONE_ORDINAL = 0
    private const val AS_DATA_PIPE_GETTER_ORDINAL = 1
    private const val READ_ALL_ORDINAL = 2
    private const val READ_RANGE_ORDINAL = 3
    private const val LOAD_ORDINAL = 4
    private const val READ_SIDE_DATA_ORDINAL = 5
    private const val CAPTURE_SNAPSHOT_ORDINAL = 6
    private const val GET_INTERNAL_UUID_ORDINAL = 7

    internal class Proxy(
        core: Core?,
        messageReceiver: MessageReceiverWithResponder?
    ) : AbstractProxy(core, messageReceiver), Blob.Proxy {
        override fun clone(
            blob: InterfaceRequest<Blob>?
        ) {
            val _message = BlobCloneParams()
            _message.blob = blob
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(CLONE_ORDINAL)
                )
            )
        }

        override fun asDataPipeGetter(
            dataPipeGetter: InterfaceRequest<DataPipeGetter>?
        ) {
            val _message = BlobAsDataPipeGetterParams()
            _message.dataPipeGetter = dataPipeGetter
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(AS_DATA_PIPE_GETTER_ORDINAL)
                )
            )
        }

        override fun readAll(
            pipe: ProducerHandle, client: BlobReaderClient?
        ) {
            val _message = BlobReadAllParams()
            _message.pipe = pipe
            _message.client = client
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(READ_ALL_ORDINAL)
                )
            )
        }

        override fun readRange(
            offset: Long, length: Long, pipe: ProducerHandle, client: BlobReaderClient?
        ) {
            val _message = BlobReadRangeParams()
            _message.offset = offset
            _message.length = length
            _message.pipe = pipe
            _message.client = client
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(READ_RANGE_ORDINAL)
                )
            )
        }

        override fun load(
            loader: InterfaceRequest<UrlLoader>?,
            requestMethod: String?,
            headers: HttpRequestHeaders?,
            client: UrlLoaderClient?
        ) {
            val _message = BlobLoadParams()
            _message.loader = loader
            _message.requestMethod = requestMethod
            _message.headers = headers
            _message.client = client
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(LOAD_ORDINAL)
                )
            )
        }

        override fun readSideData(
            callback: ReadSideDataResponse
        ) {
            val _message = BlobReadSideDataParams()
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(
                        READ_SIDE_DATA_ORDINAL,
                        MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                        0
                    )
                ),
                BlobReadSideDataResponseParamsForwardToCallback(callback)
            )
        }

        override fun captureSnapshot(
            callback: CaptureSnapshotResponse
        ) {
            val _message = BlobCaptureSnapshotParams()
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(
                        CAPTURE_SNAPSHOT_ORDINAL,
                        MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                        0
                    )
                ),
                BlobCaptureSnapshotResponseParamsForwardToCallback(callback)
            )
        }

        override fun getInternalUuid(
            callback: GetInternalUuidResponse
        ) {
            val _message = BlobGetInternalUuidParams()
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core,
                    MessageHeader(
                        GET_INTERNAL_UUID_ORDINAL,
                        MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG,
                        0
                    )
                ),
                BlobGetInternalUuidResponseParamsForwardToCallback(callback)
            )
        }
    }

    internal class Stub(core: Core?, impl: Blob?) : Interface.Stub<Blob?>(core, impl) {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                var flags = MessageHeader.NO_FLAG
                if (header.hasFlag(MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags or MessageHeader.MESSAGE_IS_SYNC_FLAG
                }
                if (!header.validateHeader(flags)) {
                    return false
                }
                when (header.type) {
                    InterfaceControlMessagesConstants.RUN_OR_CLOSE_PIPE_MESSAGE_ID -> InterfaceControlMessagesHelper.handleRunOrClosePipe(
                        MANAGER, messageWithHeader
                    )

                    CLONE_ORDINAL -> {
                        val data = BlobCloneParams.deserialize(messageWithHeader.payload)
                        impl!!.clone(data!!.blob)
                        true
                    }

                    AS_DATA_PIPE_GETTER_ORDINAL -> {
                        val data = BlobAsDataPipeGetterParams.deserialize(messageWithHeader.payload)
                        impl!!.asDataPipeGetter(data!!.dataPipeGetter)
                        true
                    }

                    READ_ALL_ORDINAL -> {
                        val data = BlobReadAllParams.deserialize(messageWithHeader.payload)
                        impl!!.readAll(data!!.pipe, data.client)
                        true
                    }

                    READ_RANGE_ORDINAL -> {
                        val data = BlobReadRangeParams.deserialize(messageWithHeader.payload)
                        impl!!.readRange(data!!.offset, data.length, data.pipe, data.client)
                        true
                    }

                    LOAD_ORDINAL -> {
                        val data = BlobLoadParams.deserialize(messageWithHeader.payload)
                        impl!!.load(data!!.loader, data.requestMethod, data.headers, data.client)
                        true
                    }

                    else -> false
                }
            } catch (e: DeserializationException) {
                System.err.println(e)
                false
            }
        }

        override fun acceptWithResponder(message: Message, receiver: MessageReceiver): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                var flags = MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG
                if (header.hasFlag(MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags or MessageHeader.MESSAGE_IS_SYNC_FLAG
                }
                if (!header.validateHeader(flags)) {
                    return false
                }
                when (header.type) {
                    InterfaceControlMessagesConstants.RUN_MESSAGE_ID -> InterfaceControlMessagesHelper.handleRun(
                        core, MANAGER, messageWithHeader, receiver
                    )

                    READ_SIDE_DATA_ORDINAL -> {
                        BlobReadSideDataParams.deserialize(messageWithHeader.payload)
                        impl!!.readSideData(
                            BlobReadSideDataResponseParamsProxyToResponder(
                                core,
                                receiver,
                                header.requestId
                            )
                        )
                        true
                    }

                    CAPTURE_SNAPSHOT_ORDINAL -> {
                        BlobCaptureSnapshotParams.deserialize(messageWithHeader.payload)
                        impl!!.captureSnapshot(
                            BlobCaptureSnapshotResponseParamsProxyToResponder(
                                core,
                                receiver,
                                header.requestId
                            )
                        )
                        true
                    }

                    GET_INTERNAL_UUID_ORDINAL -> {
                        BlobGetInternalUuidParams.deserialize(messageWithHeader.payload)
                        impl!!.getInternalUuid(
                            BlobGetInternalUuidResponseParamsProxyToResponder(
                                core,
                                receiver,
                                header.requestId
                            )
                        )
                        true
                    }

                    else -> false
                }
            } catch (e: DeserializationException) {
                System.err.println(e)
                false
            }
        }
    }

    internal class BlobCloneParams private constructor(version: Int) :
        Struct(STRUCT_SIZE, version) {
        var blob: InterfaceRequest<Blob>? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(blob, 8, false)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobCloneParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobCloneParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobCloneParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobCloneParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobCloneParams(elementsOrVersion)
                    run { result.blob = decoder0.readInterfaceRequest(8, false) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobAsDataPipeGetterParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var dataPipeGetter: InterfaceRequest<DataPipeGetter>? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(dataPipeGetter, 8, false)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobAsDataPipeGetterParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobAsDataPipeGetterParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobAsDataPipeGetterParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobAsDataPipeGetterParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobAsDataPipeGetterParams(elementsOrVersion)
                    run { result.dataPipeGetter = decoder0.readInterfaceRequest(8, false) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobReadAllParams private constructor(version: Int) :
        Struct(STRUCT_SIZE, version) {
        var pipe: ProducerHandle
        var client: BlobReaderClient? = null

        init {
            pipe = InvalidHandle.INSTANCE
        }

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(pipe, 8, false)
            encoder0.encode<BlobReaderClient?>(client, 12, true, BlobReaderClient.Companion.MANAGER)
        }

        companion object {
            private const val STRUCT_SIZE = 24
            private val VERSION_ARRAY = arrayOf(DataHeader(24, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobReadAllParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobReadAllParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobReadAllParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobReadAllParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobReadAllParams(elementsOrVersion)
                    run { result.pipe = decoder0.readProducerHandle(8, false) }
                    run {
                        result.client = decoder0.readServiceInterface<BlobReaderClient.Proxy?>(
                            12,
                            true,
                            BlobReaderClient.Companion.MANAGER
                        )
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobReadRangeParams private constructor(version: Int) :
        Struct(STRUCT_SIZE, version) {
        var offset: Long = 0
        var length: Long = 0
        var pipe: ProducerHandle
        var client: BlobReaderClient? = null

        init {
            pipe = InvalidHandle.INSTANCE
        }

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(offset, 8)
            encoder0.encode(length, 16)
            encoder0.encode(pipe, 24, false)
            encoder0.encode<BlobReaderClient?>(client, 28, true, BlobReaderClient.Companion.MANAGER)
        }

        companion object {
            private const val STRUCT_SIZE = 40
            private val VERSION_ARRAY = arrayOf(DataHeader(40, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobReadRangeParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobReadRangeParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobReadRangeParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobReadRangeParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobReadRangeParams(elementsOrVersion)
                    run { result.offset = decoder0.readLong(8) }
                    run { result.length = decoder0.readLong(16) }
                    run { result.pipe = decoder0.readProducerHandle(24, false) }
                    run {
                        result.client = decoder0.readServiceInterface<BlobReaderClient.Proxy?>(
                            28,
                            true,
                            BlobReaderClient.Companion.MANAGER
                        )
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobLoadParams private constructor(version: Int) : Struct(STRUCT_SIZE, version) {
        var loader: InterfaceRequest<UrlLoader>? = null
        var requestMethod: String? = null
        var headers: HttpRequestHeaders? = null
        var client: UrlLoaderClient? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(loader, 8, false)
            encoder0.encode(requestMethod, 16, false)
            encoder0.encode(headers, 24, false)
            encoder0.encode(client, 32, false, UrlLoaderClient.MANAGER)
        }

        companion object {
            private const val STRUCT_SIZE = 40
            private val VERSION_ARRAY = arrayOf(DataHeader(40, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobLoadParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobLoadParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobLoadParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobLoadParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobLoadParams(elementsOrVersion)
                    run { result.loader = decoder0.readInterfaceRequest(8, false) }
                    run { result.requestMethod = decoder0.readString(16, false) }
                    run {
                        val decoder1 = decoder0.readPointer(24, false)
                        result.headers = HttpRequestHeaders.decode(decoder1)
                    }
                    run {
                        result.client =
                            decoder0.readServiceInterface(32, false, UrlLoaderClient.MANAGER)
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobReadSideDataParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        }

        companion object {
            private const val STRUCT_SIZE = 8
            private val VERSION_ARRAY = arrayOf(DataHeader(8, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobReadSideDataParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobReadSideDataParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobReadSideDataParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobReadSideDataParams
                result = try {
                    val mainDataHeader =
                        decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    BlobReadSideDataParams(elementsOrVersion)
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobReadSideDataResponseParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var data: BigBuffer? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(data, 8, true)
        }

        companion object {
            private const val STRUCT_SIZE = 24
            private val VERSION_ARRAY = arrayOf(DataHeader(24, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobReadSideDataResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobReadSideDataResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobReadSideDataResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobReadSideDataResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobReadSideDataResponseParams(elementsOrVersion)
                    run { result.data = BigBuffer.decode(decoder0, 8) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobReadSideDataResponseParamsForwardToCallback(private val mCallback: ReadSideDataResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        READ_SIDE_DATA_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG
                    )
                ) {
                    return false
                }
                val response = BlobReadSideDataResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.data)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class BlobReadSideDataResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : ReadSideDataResponse {
        override fun call(data: BigBuffer?) {
            val _response = BlobReadSideDataResponseParams()
            _response.data = data
            val _message = _response.serializeWithHeader(
                mCore,
                MessageHeader(
                    READ_SIDE_DATA_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }

    internal class BlobCaptureSnapshotParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        }

        companion object {
            private const val STRUCT_SIZE = 8
            private val VERSION_ARRAY = arrayOf(DataHeader(8, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobCaptureSnapshotParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobCaptureSnapshotParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobCaptureSnapshotParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobCaptureSnapshotParams
                result = try {
                    val mainDataHeader =
                        decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    BlobCaptureSnapshotParams(elementsOrVersion)
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobCaptureSnapshotResponseParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var length: Long = 0
        var modificationTime: Time? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(length, 8)
            encoder0.encode(modificationTime, 16, true)
        }

        companion object {
            private const val STRUCT_SIZE = 24
            private val VERSION_ARRAY = arrayOf(DataHeader(24, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobCaptureSnapshotResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobCaptureSnapshotResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobCaptureSnapshotResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobCaptureSnapshotResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobCaptureSnapshotResponseParams(elementsOrVersion)
                    run { result.length = decoder0.readLong(8) }
                    run {
                        val decoder1 = decoder0.readPointer(16, true)
                        result.modificationTime = Time.decode(decoder1)
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobCaptureSnapshotResponseParamsForwardToCallback(private val mCallback: CaptureSnapshotResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        CAPTURE_SNAPSHOT_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG
                    )
                ) {
                    return false
                }
                val response =
                    BlobCaptureSnapshotResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.length, response.modificationTime)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class BlobCaptureSnapshotResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : CaptureSnapshotResponse {
        override fun call(length: Long?, modificationTime: Time?) {
            val _response = BlobCaptureSnapshotResponseParams()
            _response.length = length!!
            _response.modificationTime = modificationTime
            val _message = _response.serializeWithHeader(
                mCore,
                MessageHeader(
                    CAPTURE_SNAPSHOT_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }

    internal class BlobGetInternalUuidParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        }

        companion object {
            private const val STRUCT_SIZE = 8
            private val VERSION_ARRAY = arrayOf(DataHeader(8, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobGetInternalUuidParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobGetInternalUuidParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobGetInternalUuidParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobGetInternalUuidParams
                result = try {
                    val mainDataHeader =
                        decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    BlobGetInternalUuidParams(elementsOrVersion)
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobGetInternalUuidResponseParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var uuid: String? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(uuid, 8, false)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): BlobGetInternalUuidResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): BlobGetInternalUuidResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): BlobGetInternalUuidResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: BlobGetInternalUuidResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = BlobGetInternalUuidResponseParams(elementsOrVersion)
                    run { result.uuid = decoder0.readString(8, false) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class BlobGetInternalUuidResponseParamsForwardToCallback(private val mCallback: GetInternalUuidResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        GET_INTERNAL_UUID_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG
                    )
                ) {
                    return false
                }
                val response =
                    BlobGetInternalUuidResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.uuid)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class BlobGetInternalUuidResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : GetInternalUuidResponse {
        override fun call(uuid: String?) {
            val _response = BlobGetInternalUuidResponseParams()
            _response.uuid = uuid
            val _message = _response.serializeWithHeader(
                mCore,
                MessageHeader(
                    GET_INTERNAL_UUID_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }
}