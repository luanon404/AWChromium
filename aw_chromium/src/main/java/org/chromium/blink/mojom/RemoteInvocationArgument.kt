// RemoteInvocationArgument.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/remote_objects/remote_objects.mojom
//
package org.chromium.blink.mojom

import org.chromium.mojo.bindings.BindingsHelper
import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.Union
import org.chromium.mojo_base.mojom.String16

class RemoteInvocationArgument : Union() {
    object Tag {
        const val NumberValue = 0
        const val BooleanValue = 1
        const val StringValue = 2
        const val SingletonValue = 3
        const val ArrayValue = 4
        const val TypedArrayValue = 5
        const val ObjectIdValue = 6
    }

    private var mNumberValue = 0.0
    private var mBooleanValue = false
    private var mStringValue: String16? = null
    private var mSingletonValue = 0
    private var mArrayValue: Array<RemoteInvocationArgument?>? = null
    private var mTypedArrayValue: RemoteTypedArray? = null
    private var mObjectIdValue = 0
    var numberValue: Double
        get() {
            assert(mTag == Tag.NumberValue)
            return mNumberValue
        }
        set(numberValue) {
            mTag = Tag.NumberValue
            mNumberValue = numberValue
        }
    var booleanValue: Boolean
        get() {
            assert(mTag == Tag.BooleanValue)
            return mBooleanValue
        }
        set(booleanValue) {
            mTag = Tag.BooleanValue
            mBooleanValue = booleanValue
        }
    var stringValue: String16?
        get() {
            assert(mTag == Tag.StringValue)
            return mStringValue
        }
        set(stringValue) {
            mTag = Tag.StringValue
            mStringValue = stringValue
        }
    var singletonValue: Int
        get() {
            assert(mTag == Tag.SingletonValue)
            return mSingletonValue
        }
        set(singletonValue) {
            mTag = Tag.SingletonValue
            mSingletonValue = singletonValue
        }
    var arrayValue: Array<RemoteInvocationArgument?>?
        get() {
            assert(mTag == Tag.ArrayValue)
            return mArrayValue
        }
        set(arrayValue) {
            mTag = Tag.ArrayValue
            mArrayValue = arrayValue
        }
    var typedArrayValue: RemoteTypedArray?
        get() {
            assert(mTag == Tag.TypedArrayValue)
            return mTypedArrayValue
        }
        set(typedArrayValue) {
            mTag = Tag.TypedArrayValue
            mTypedArrayValue = typedArrayValue
        }
    var objectIdValue: Int
        get() {
            assert(mTag == Tag.ObjectIdValue)
            return mObjectIdValue
        }
        set(objectIdValue) {
            mTag = Tag.ObjectIdValue
            mObjectIdValue = objectIdValue
        }

    override fun encode(encoder0: Encoder, offset: Int) {
        encoder0.encode(BindingsHelper.UNION_SIZE, offset)
        encoder0.encode(mTag, offset + 4)
        when (mTag) {
            Tag.NumberValue -> {
                encoder0.encode(mNumberValue, offset + 8)
            }

            Tag.BooleanValue -> {
                encoder0.encode(mBooleanValue, offset + 8, 0)
            }

            Tag.StringValue -> {
                encoder0.encode(mStringValue, offset + 8, false)
            }

            Tag.SingletonValue -> {
                encoder0.encode(mSingletonValue, offset + 8)
            }

            Tag.ArrayValue -> {
                if (mArrayValue == null) {
                    encoder0.encodeNullPointer(offset + 8, false)
                } else {
                    val encoder1 = encoder0.encodeUnionArray(
                        mArrayValue!!.size, offset + 8, BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
                    )
                    var i0 = 0
                    while (i0 < mArrayValue!!.size) {
                        encoder1.encode(
                            mArrayValue!![i0],
                            DataHeader.HEADER_SIZE + BindingsHelper.UNION_SIZE * i0,
                            false
                        )
                        ++i0
                    }
                }
            }

            Tag.TypedArrayValue -> {
                encoder0.encode(mTypedArrayValue, offset + 8, false)
            }

            Tag.ObjectIdValue -> {
                encoder0.encode(mObjectIdValue, offset + 8)
            }

            else -> {}
        }
    }

    companion object {
        fun deserialize(message: Message?): RemoteInvocationArgument? {
            return decode(Decoder(message).decoderForSerializedUnion(), 0)
        }

        fun decode(decoder0: Decoder, offset: Int): RemoteInvocationArgument? {
            val dataHeader = decoder0.readDataHeaderForUnion(offset)
            if (dataHeader.size == 0) {
                return null
            }
            val result = RemoteInvocationArgument()
            when (dataHeader.elementsOrVersion) {
                Tag.NumberValue -> {
                    result.mNumberValue = decoder0.readDouble(offset + DataHeader.HEADER_SIZE)
                    result.mTag = Tag.NumberValue
                }

                Tag.BooleanValue -> {
                    result.mBooleanValue = decoder0.readBoolean(offset + DataHeader.HEADER_SIZE, 0)
                    result.mTag = Tag.BooleanValue
                }

                Tag.StringValue -> {
                    val decoder1 = decoder0.readPointer(offset + DataHeader.HEADER_SIZE, false)
                    result.mStringValue = String16.decode(decoder1)
                    result.mTag = Tag.StringValue
                }

                Tag.SingletonValue -> {
                    result.mSingletonValue = decoder0.readInt(offset + DataHeader.HEADER_SIZE)
                    SingletonJavaScriptValue.validate(result.mSingletonValue)
                    result.mSingletonValue =
                        SingletonJavaScriptValue.toKnownValue(result.mSingletonValue)
                    result.mTag = Tag.SingletonValue
                }

                Tag.ArrayValue -> {
                    val decoder1 = decoder0.readPointer(offset + DataHeader.HEADER_SIZE, false)
                    run {
                        val si1 =
                            decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                        result.mArrayValue = arrayOfNulls(si1.elementsOrVersion)
                        var i1 = 0
                        while (i1 < si1.elementsOrVersion) {
                            result.mArrayValue!![i1] = decode(
                                decoder1, DataHeader.HEADER_SIZE + BindingsHelper.UNION_SIZE * i1
                            )
                            ++i1
                        }
                    }
                    result.mTag = Tag.ArrayValue
                }

                Tag.TypedArrayValue -> {
                    val decoder1 = decoder0.readPointer(offset + DataHeader.HEADER_SIZE, false)
                    result.mTypedArrayValue = RemoteTypedArray.decode(decoder1)
                    result.mTag = Tag.TypedArrayValue
                }

                Tag.ObjectIdValue -> {
                    result.mObjectIdValue = decoder0.readInt(offset + DataHeader.HEADER_SIZE)
                    result.mTag = Tag.ObjectIdValue
                }

                else -> {}
            }
            return result
        }
    }
}