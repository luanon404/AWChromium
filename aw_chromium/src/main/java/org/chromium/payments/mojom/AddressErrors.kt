// AddressErrors.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     components/payments/mojom/payment_request_data.mojom
//
package org.chromium.payments.mojom

import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.Struct
import java.nio.ByteBuffer

class AddressErrors private constructor(version: Int) : Struct(STRUCT_SIZE, version) {
    var addressLine: String? = null
    var city: String? = null
    var country: String? = null
    var dependentLocality: String? = null
    var organization: String? = null
    var phone: String? = null
    var postalCode: String? = null
    var recipient: String? = null
    var region: String? = null
    var sortingCode: String? = null

    override fun encode(encoder: Encoder) {
        val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        encoder0.encode(addressLine, 8, false)
        encoder0.encode(city, 16, false)
        encoder0.encode(country, 24, false)
        encoder0.encode(dependentLocality, 32, false)
        encoder0.encode(organization, 40, false)
        encoder0.encode(phone, 48, false)
        encoder0.encode(postalCode, 56, false)
        encoder0.encode(recipient, 64, false)
        encoder0.encode(region, 72, false)
        encoder0.encode(sortingCode, 80, false)
    }

    companion object {
        private const val STRUCT_SIZE = 88
        private val VERSION_ARRAY = arrayOf(DataHeader(88, 0))
        private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
        fun deserialize(message: Message?): AddressErrors? {
            return decode(Decoder(message))
        }

        /**
         * Similar to the method above, but deserializes from a |ByteBuffer| instance.
         *
         * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
         */
        fun deserialize(data: ByteBuffer?): AddressErrors? {
            return deserialize(
                Message(
                    data, ArrayList()
                )
            )
        }

        fun decode(decoder0: Decoder?): AddressErrors? {
            if (decoder0 == null) {
                return null
            }
            decoder0.increaseStackDepth()
            val result: AddressErrors
            try {
                val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                val elementsOrVersion = mainDataHeader.elementsOrVersion
                result = AddressErrors(elementsOrVersion)
                run { result.addressLine = decoder0.readString(8, false) }
                run { result.city = decoder0.readString(16, false) }
                run { result.country = decoder0.readString(24, false) }
                run { result.dependentLocality = decoder0.readString(32, false) }
                run { result.organization = decoder0.readString(40, false) }
                run { result.phone = decoder0.readString(48, false) }
                run { result.postalCode = decoder0.readString(56, false) }
                run { result.recipient = decoder0.readString(64, false) }
                run { result.region = decoder0.readString(72, false) }
                run { result.sortingCode = decoder0.readString(80, false) }
            } finally {
                decoder0.decreaseStackDepth()
            }
            return result
        }
    }
}