// RemoteObject_Internal.java is auto generated by mojom_bindings_generator.py, do not edit
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// This file is autogenerated by:
//     mojo/public/tools/bindings/mojom_bindings_generator.py
// For:
//     third_party/blink/public/mojom/remote_objects/remote_objects.mojom
//
package org.chromium.blink.mojom

import org.chromium.blink.mojom.RemoteObject.GetMethodsResponse
import org.chromium.blink.mojom.RemoteObject.HasMethodResponse
import org.chromium.blink.mojom.RemoteObject.InvokeMethodResponse
import org.chromium.mojo.bindings.BindingsHelper
import org.chromium.mojo.bindings.DataHeader
import org.chromium.mojo.bindings.Decoder
import org.chromium.mojo.bindings.DeserializationException
import org.chromium.mojo.bindings.Encoder
import org.chromium.mojo.bindings.Interface
import org.chromium.mojo.bindings.Interface.AbstractProxy
import org.chromium.mojo.bindings.Interface.Manager
import org.chromium.mojo.bindings.InterfaceControlMessagesHelper
import org.chromium.mojo.bindings.Message
import org.chromium.mojo.bindings.MessageHeader
import org.chromium.mojo.bindings.MessageReceiver
import org.chromium.mojo.bindings.MessageReceiverWithResponder
import org.chromium.mojo.bindings.SideEffectFreeCloseable
import org.chromium.mojo.bindings.Struct
import org.chromium.mojo.bindings.interfacecontrol.InterfaceControlMessagesConstants
import org.chromium.mojo.system.Core
import java.nio.ByteBuffer

internal object RemoteObjectInternal {
    val MANAGER: Manager<RemoteObject?, RemoteObject.Proxy?> =
        object : Manager<RemoteObject?, RemoteObject.Proxy?>() {
            override fun getName(): String {
                return "blink.mojom.RemoteObject"
            }

            override fun getVersion(): Int {
                return 0
            }

            public override fun buildProxy(
                core: Core, messageReceiver: MessageReceiverWithResponder
            ): Proxy {
                return Proxy(core, messageReceiver)
            }

            override fun buildStub(
                core: Core?, impl: RemoteObject?
            ): Interface.Stub<RemoteObject?> {
                return Stub(core, impl)
            }

            public override fun buildArray(size: Int): Array<RemoteObject?> {
                return arrayOfNulls(size)
            }
        }
    private const val HAS_METHOD_ORDINAL = 0
    private const val GET_METHODS_ORDINAL = 1
    private const val INVOKE_METHOD_ORDINAL = 2
    private const val NOTIFY_RELEASED_OBJECT_ORDINAL = 3

    internal class Proxy(
        core: Core?, messageReceiver: MessageReceiverWithResponder?
    ) : AbstractProxy(core, messageReceiver), RemoteObject.Proxy {
        override fun hasMethod(
            name: String?, callback: HasMethodResponse
        ) {
            val _message = RemoteObjectHasMethodParams()
            _message.name = name
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core, MessageHeader(
                        HAS_METHOD_ORDINAL, MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG, 0
                    )
                ), RemoteObjectHasMethodResponseParamsForwardToCallback(callback)
            )
        }

        override fun getMethods(
            callback: GetMethodsResponse
        ) {
            val _message = RemoteObjectGetMethodsParams()
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core, MessageHeader(
                        GET_METHODS_ORDINAL, MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG, 0
                    )
                ), RemoteObjectGetMethodsResponseParamsForwardToCallback(callback)
            )
        }

        override fun invokeMethod(
            name: String?,
            arguments: Array<RemoteInvocationArgument?>?,
            callback: InvokeMethodResponse
        ) {
            val _message = RemoteObjectInvokeMethodParams()
            _message.name = name
            _message.arguments = arguments
            proxyHandler.messageReceiver.acceptWithResponder(
                _message.serializeWithHeader(
                    proxyHandler.core, MessageHeader(
                        INVOKE_METHOD_ORDINAL, MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG, 0
                    )
                ), RemoteObjectInvokeMethodResponseParamsForwardToCallback(callback)
            )
        }

        override fun notifyReleasedObject() {
            val _message = RemoteObjectNotifyReleasedObjectParams()
            proxyHandler.messageReceiver.accept(
                _message.serializeWithHeader(
                    proxyHandler.core, MessageHeader(NOTIFY_RELEASED_OBJECT_ORDINAL)
                )
            )
        }
    }

    internal class Stub(core: Core?, impl: RemoteObject?) :
        Interface.Stub<RemoteObject?>(core, impl) {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                var flags = MessageHeader.NO_FLAG
                if (header.hasFlag(MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags or MessageHeader.MESSAGE_IS_SYNC_FLAG
                }
                if (!header.validateHeader(flags)) {
                    return false
                }
                when (header.type) {
                    InterfaceControlMessagesConstants.RUN_OR_CLOSE_PIPE_MESSAGE_ID -> InterfaceControlMessagesHelper.handleRunOrClosePipe(
                        MANAGER, messageWithHeader
                    )

                    NOTIFY_RELEASED_OBJECT_ORDINAL -> {
                        RemoteObjectNotifyReleasedObjectParams.deserialize(messageWithHeader.payload)
                        impl!!.notifyReleasedObject()
                        true
                    }

                    else -> false
                }
            } catch (e: DeserializationException) {
                System.err.println(e)
                false
            }
        }

        override fun acceptWithResponder(message: Message, receiver: MessageReceiver): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                var flags = MessageHeader.MESSAGE_EXPECTS_RESPONSE_FLAG
                if (header.hasFlag(MessageHeader.MESSAGE_IS_SYNC_FLAG)) {
                    flags = flags or MessageHeader.MESSAGE_IS_SYNC_FLAG
                }
                if (!header.validateHeader(flags)) {
                    return false
                }
                when (header.type) {
                    InterfaceControlMessagesConstants.RUN_MESSAGE_ID -> InterfaceControlMessagesHelper.handleRun(
                        core, MANAGER, messageWithHeader, receiver
                    )

                    HAS_METHOD_ORDINAL -> {
                        val data =
                            RemoteObjectHasMethodParams.deserialize(messageWithHeader.payload)
                        impl!!.hasMethod(
                            data!!.name, RemoteObjectHasMethodResponseParamsProxyToResponder(
                                core, receiver, header.requestId
                            )
                        )
                        true
                    }

                    GET_METHODS_ORDINAL -> {
                        RemoteObjectGetMethodsParams.deserialize(messageWithHeader.payload)
                        impl!!.getMethods(
                            RemoteObjectGetMethodsResponseParamsProxyToResponder(
                                core, receiver, header.requestId
                            )
                        )
                        true
                    }

                    INVOKE_METHOD_ORDINAL -> {
                        val data =
                            RemoteObjectInvokeMethodParams.deserialize(messageWithHeader.payload)
                        impl!!.invokeMethod(
                            data!!.name,
                            data.arguments,
                            RemoteObjectInvokeMethodResponseParamsProxyToResponder(
                                core, receiver, header.requestId
                            )
                        )
                        true
                    }

                    else -> false
                }
            } catch (e: DeserializationException) {
                System.err.println(e)
                false
            }
        }
    }

    internal class RemoteObjectHasMethodParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var name: String? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(name, 8, false)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectHasMethodParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectHasMethodParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectHasMethodParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectHasMethodParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = RemoteObjectHasMethodParams(elementsOrVersion)
                    run { result.name = decoder0.readString(8, false) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectHasMethodResponseParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var methodExists = false

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(methodExists, 8, 0)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectHasMethodResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectHasMethodResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectHasMethodResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectHasMethodResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = RemoteObjectHasMethodResponseParams(elementsOrVersion)
                    run { result.methodExists = decoder0.readBoolean(8, 0) }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectHasMethodResponseParamsForwardToCallback(private val mCallback: HasMethodResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        HAS_METHOD_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG
                    )
                ) {
                    return false
                }
                val response =
                    RemoteObjectHasMethodResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.methodExists)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class RemoteObjectHasMethodResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : HasMethodResponse {
        override fun call(methodExists: Boolean?) {
            val _response = RemoteObjectHasMethodResponseParams()
            _response.methodExists = methodExists!!
            val _message = _response.serializeWithHeader(
                mCore, MessageHeader(
                    HAS_METHOD_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }

    internal class RemoteObjectGetMethodsParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        }

        companion object {
            private const val STRUCT_SIZE = 8
            private val VERSION_ARRAY = arrayOf(DataHeader(8, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectGetMethodsParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectGetMethodsParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectGetMethodsParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectGetMethodsParams = try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    RemoteObjectGetMethodsParams(elementsOrVersion)
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectGetMethodsResponseParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        lateinit var methodNames: Array<String?>

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            val encoder1 = encoder0.encodePointerArray(
                methodNames.size, 8, BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
            )
            for (i0 in methodNames.indices) {
                encoder1.encode(
                    methodNames[i0],
                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i0,
                    false
                )
            }
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectGetMethodsResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectGetMethodsResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectGetMethodsResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectGetMethodsResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = RemoteObjectGetMethodsResponseParams(elementsOrVersion)
                    run {
                        val decoder1 = decoder0.readPointer(8, false)
                        run {
                            val si1 =
                                decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                            result.methodNames = arrayOfNulls(si1.elementsOrVersion)
                            for (i1 in 0 until si1.elementsOrVersion) {
                                result.methodNames[i1] = decoder1.readString(
                                    DataHeader.HEADER_SIZE + BindingsHelper.POINTER_SIZE * i1, false
                                )
                            }
                        }
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectGetMethodsResponseParamsForwardToCallback(private val mCallback: GetMethodsResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        GET_METHODS_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG
                    )
                ) {
                    return false
                }
                val response =
                    RemoteObjectGetMethodsResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.methodNames)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class RemoteObjectGetMethodsResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : GetMethodsResponse {
        override fun call(methodNames: Array<String?>?) {
            val _response = RemoteObjectGetMethodsResponseParams()
            _response.methodNames = methodNames!!
            val _message = _response.serializeWithHeader(
                mCore, MessageHeader(
                    GET_METHODS_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }

    internal class RemoteObjectInvokeMethodParams private constructor(version: Int) : Struct(
        STRUCT_SIZE, version
    ) {
        var name: String? = null
        var arguments: Array<RemoteInvocationArgument?>? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(name, 8, false)
            if (arguments == null) {
                encoder0.encodeNullPointer(16, false)
            } else {
                val encoder1 = encoder0.encodeUnionArray(
                    arguments!!.size, 16, BindingsHelper.UNSPECIFIED_ARRAY_LENGTH
                )
                for (i0 in arguments!!.indices) {
                    encoder1.encode(
                        arguments!![i0],
                        DataHeader.HEADER_SIZE + BindingsHelper.UNION_SIZE * i0,
                        false
                    )
                }
            }
        }

        companion object {
            private const val STRUCT_SIZE = 24
            private val VERSION_ARRAY = arrayOf(DataHeader(24, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectInvokeMethodParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectInvokeMethodParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectInvokeMethodParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectInvokeMethodParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = RemoteObjectInvokeMethodParams(elementsOrVersion)
                    run { result.name = decoder0.readString(8, false) }
                    run {
                        val decoder1 = decoder0.readPointer(16, false)
                        run {
                            val si1 =
                                decoder1.readDataHeaderForPointerArray(BindingsHelper.UNSPECIFIED_ARRAY_LENGTH)
                            result.arguments = arrayOfNulls(si1.elementsOrVersion)
                            for (i1 in 0 until si1.elementsOrVersion) {
                                result.arguments!![i1] = RemoteInvocationArgument.decode(
                                    decoder1,
                                    DataHeader.HEADER_SIZE + BindingsHelper.UNION_SIZE * i1
                                )
                            }
                        }
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectInvokeMethodResponseParams private constructor(version: Int) :
        Struct(
            STRUCT_SIZE, version
        ) {
        var result: RemoteInvocationResult? = null

        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            val encoder0 = encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
            encoder0.encode(result, 8, false)
        }

        companion object {
            private const val STRUCT_SIZE = 16
            private val VERSION_ARRAY = arrayOf(DataHeader(16, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectInvokeMethodResponseParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectInvokeMethodResponseParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectInvokeMethodResponseParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectInvokeMethodResponseParams
                try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    result = RemoteObjectInvokeMethodResponseParams(elementsOrVersion)
                    run {
                        val decoder1 = decoder0.readPointer(8, false)
                        result.result = RemoteInvocationResult.decode(decoder1)
                    }
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }

    internal class RemoteObjectInvokeMethodResponseParamsForwardToCallback(private val mCallback: InvokeMethodResponse) :
        SideEffectFreeCloseable(), MessageReceiver {
        override fun accept(message: Message): Boolean {
            return try {
                val messageWithHeader = message.asServiceMessage()
                val header = messageWithHeader.header
                if (!header.validateHeader(
                        INVOKE_METHOD_ORDINAL,
                        MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG
                    )
                ) {
                    return false
                }
                val response =
                    RemoteObjectInvokeMethodResponseParams.deserialize(messageWithHeader.payload)
                mCallback.call(response!!.result)
                true
            } catch (e: DeserializationException) {
                false
            }
        }
    }

    internal class RemoteObjectInvokeMethodResponseParamsProxyToResponder(
        private val mCore: Core,
        private val mMessageReceiver: MessageReceiver,
        private val mRequestId: Long
    ) : InvokeMethodResponse {
        override fun call(result: RemoteInvocationResult?) {
            val _response = RemoteObjectInvokeMethodResponseParams()
            _response.result = result
            val _message = _response.serializeWithHeader(
                mCore, MessageHeader(
                    INVOKE_METHOD_ORDINAL,
                    MessageHeader.MESSAGE_IS_RESPONSE_FLAG or MessageHeader.MESSAGE_IS_SYNC_FLAG,
                    mRequestId
                )
            )
            mMessageReceiver.accept(_message)
        }
    }

    internal class RemoteObjectNotifyReleasedObjectParams private constructor(version: Int) :
        Struct(
            STRUCT_SIZE, version
        ) {
        constructor() : this(0)

        override fun encode(encoder: Encoder) {
            encoder.getEncoderAtDataOffset(DEFAULT_STRUCT_INFO)
        }

        companion object {
            private const val STRUCT_SIZE = 8
            private val VERSION_ARRAY = arrayOf(DataHeader(8, 0))
            private val DEFAULT_STRUCT_INFO = VERSION_ARRAY[0]
            fun deserialize(message: Message?): RemoteObjectNotifyReleasedObjectParams? {
                return decode(Decoder(message))
            }

            /**
             * Similar to the method above, but deserializes from a |ByteBuffer| instance.
             *
             * @throws org.chromium.mojo.bindings.DeserializationException on deserialization failure.
             */
            fun deserialize(data: ByteBuffer?): RemoteObjectNotifyReleasedObjectParams? {
                return deserialize(
                    Message(
                        data, ArrayList()
                    )
                )
            }

            fun decode(decoder0: Decoder?): RemoteObjectNotifyReleasedObjectParams? {
                if (decoder0 == null) {
                    return null
                }
                decoder0.increaseStackDepth()
                val result: RemoteObjectNotifyReleasedObjectParams = try {
                    val mainDataHeader = decoder0.readAndValidateDataHeader(VERSION_ARRAY)
                    val elementsOrVersion = mainDataHeader.elementsOrVersion
                    RemoteObjectNotifyReleasedObjectParams(elementsOrVersion)
                } finally {
                    decoder0.decreaseStackDepth()
                }
                return result
            }
        }
    }
}